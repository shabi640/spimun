import {
  computed,
  createBlock,
  defineComponent,
  markRaw,
  mergeModels,
  onBeforeUnmount,
  onMounted,
  openBlock,
  ref,
  resolveDynamicComponent,
  shallowReadonly,
  toValue,
  useModel,
  version,
  watch,
  watchEffect
} from "./chunk-P4JRBGFP.js";
import {
  debounce_default
} from "./chunk-PC23ODDI.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js
function waitFor(callback, {
  timeOutAfter = 500,
  retryAfter = 100
} = {}) {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    let lastError = null;
    const timeoutTimerId = setTimeout(() => {
      reject(lastError ?? new Error("Timeout"));
    }, timeOutAfter);
    const tick = async () => {
      try {
        const result = await callback();
        clearTimeout(timeoutTimerId);
        resolve(result);
      } catch (err) {
        lastError = err;
        if (Date.now() - startTime > timeOutAfter) {
          reject(err);
        } else {
          setTimeout(tick, retryAfter);
        }
      }
    };
    tick();
  });
}
var INJECTED_SCRIPTS = /* @__PURE__ */ new Map();
function injectScript(src, { attributes } = {}) {
  if (INJECTED_SCRIPTS.has(src)) {
    return INJECTED_SCRIPTS.get(src);
  }
  const maybePrevScript = document.querySelector(`script[src="${src}"]`);
  if (maybePrevScript) {
    console.warn(`Script with "${src}" src is already present in DOM!`);
    maybePrevScript.remove();
  }
  const promise = new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.onerror = reject;
    script.onload = () => {
      resolve();
    };
    for (const [key, value] of Object.entries(attributes || {})) {
      script.setAttribute(key, value);
    }
    script.setAttribute("data-injected-by", "ckeditor-integration");
    script.type = "text/javascript";
    script.async = true;
    script.src = src;
    document.head.appendChild(script);
    const observer = new MutationObserver((mutations) => {
      const removedNodes = mutations.flatMap((mutation) => Array.from(mutation.removedNodes));
      if (removedNodes.includes(script)) {
        INJECTED_SCRIPTS.delete(src);
        observer.disconnect();
      }
    });
    observer.observe(document.head, {
      childList: true,
      subtree: true
    });
  });
  INJECTED_SCRIPTS.set(src, promise);
  return promise;
}
async function injectScriptsInParallel(sources, props) {
  await Promise.all(
    sources.map((src) => injectScript(src, props))
  );
}
var INJECTED_STYLESHEETS = /* @__PURE__ */ new Map();
function injectStylesheet({
  href,
  placementInHead = "start",
  attributes = {}
}) {
  if (INJECTED_STYLESHEETS.has(href)) {
    return INJECTED_STYLESHEETS.get(href);
  }
  const maybePrevStylesheet = document.querySelector(`link[href="${href}"][rel="stylesheet"]`);
  if (maybePrevStylesheet) {
    console.warn(`Stylesheet with "${href}" href is already present in DOM!`);
    maybePrevStylesheet.remove();
  }
  const appendLinkTagToHead = (link) => {
    const previouslyInjectedLinks = Array.from(
      document.head.querySelectorAll('link[data-injected-by="ckeditor-integration"]')
    );
    switch (placementInHead) {
      case "start":
        if (previouslyInjectedLinks.length) {
          previouslyInjectedLinks.slice(-1)[0].after(link);
        } else {
          document.head.insertBefore(link, document.head.firstChild);
        }
        break;
      case "end":
        document.head.appendChild(link);
        break;
    }
  };
  const promise = new Promise((resolve, reject) => {
    const link = document.createElement("link");
    for (const [key, value] of Object.entries(attributes || {})) {
      link.setAttribute(key, value);
    }
    link.setAttribute("data-injected-by", "ckeditor-integration");
    link.rel = "stylesheet";
    link.href = href;
    link.onerror = reject;
    link.onload = () => {
      resolve();
    };
    appendLinkTagToHead(link);
    const observer = new MutationObserver((mutations) => {
      const removedNodes = mutations.flatMap((mutation) => Array.from(mutation.removedNodes));
      if (removedNodes.includes(link)) {
        INJECTED_STYLESHEETS.delete(href);
        observer.disconnect();
      }
    });
    observer.observe(document.head, {
      childList: true,
      subtree: true
    });
  });
  INJECTED_STYLESHEETS.set(href, promise);
  return promise;
}
function preloadResource(url, { attributes } = {}) {
  if (document.head.querySelector(`link[href="${url}"][rel="preload"]`)) {
    return;
  }
  const link = document.createElement("link");
  for (const [key, value] of Object.entries(attributes || {})) {
    link.setAttribute(key, value);
  }
  link.setAttribute("data-injected-by", "ckeditor-integration");
  link.rel = "preload";
  link.as = detectTypeOfResource(url);
  link.href = url;
  document.head.insertBefore(link, document.head.firstChild);
}
function detectTypeOfResource(url) {
  switch (true) {
    case /\.css$/.test(url):
      return "style";
    case /\.js$/.test(url):
      return "script";
    default:
      return "fetch";
  }
}
var HEX_NUMBERS = new Array(256).fill("").map((_, index) => ("0" + index.toString(16)).slice(-2));
function uid() {
  const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));
  return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}
function uniq(source) {
  return Array.from(new Set(source));
}
async function waitForWindowEntry(entryNames, config) {
  const tryPickBundle = () => entryNames.map((name) => window[name]).filter(Boolean)[0];
  return waitFor(
    () => {
      const result = tryPickBundle();
      if (!result) {
        throw new Error(`Window entry "${entryNames.join(",")}" not found.`);
      }
      return result;
    },
    config
  );
}
function filterObjectValues(obj, filter) {
  const filteredEntries = Object.entries(obj).filter(([key, value]) => filter(value, key));
  return Object.fromEntries(filteredEntries);
}
function filterBlankObjectValues(obj) {
  return filterObjectValues(
    obj,
    (value) => value !== null && value !== void 0
  );
}
function mapObjectValues(obj, mapper) {
  const mappedEntries = Object.entries(obj).map(([key, value]) => [key, mapper(value, key)]);
  return Object.fromEntries(mappedEntries);
}
function without(itemsToRemove, items) {
  return items.filter((item) => !itemsToRemove.includes(item));
}
function appendExtraPluginsToEditorConfig(config, plugins) {
  const extraPlugins = config.extraPlugins || [];
  return {
    ...config,
    extraPlugins: [
      ...extraPlugins,
      ...plugins.filter((item) => !extraPlugins.includes(item))
    ]
  };
}
function isSemanticVersion(version2) {
  return !!version2 && /^\d+\.\d+\.\d+/.test(version2);
}
function isCKCdnTestingVersion(version2) {
  if (!version2) {
    return false;
  }
  return ["nightly", "alpha", "internal", "nightly-", "staging"].some((testVersion) => version2.includes(testVersion));
}
function isCKCdnVersion(version2) {
  return isSemanticVersion(version2) || isCKCdnTestingVersion(version2);
}
function destructureSemanticVersion(version2) {
  if (!isSemanticVersion(version2)) {
    throw new Error(`Invalid semantic version: ${version2 || "<blank>"}.`);
  }
  const [major, minor, patch] = version2.split(".");
  return {
    major: Number.parseInt(major, 10),
    minor: Number.parseInt(minor, 10),
    patch: Number.parseInt(patch, 10)
  };
}
function getLicenseVersionFromEditorVersion(version2) {
  if (isCKCdnTestingVersion(version2)) {
    return 3;
  }
  const { major } = destructureSemanticVersion(version2);
  switch (true) {
    case major >= 44:
      return 3;
    case major >= 38:
      return 2;
    default:
      return 1;
  }
}
function getCKBaseBundleInstallationInfo() {
  const { CKEDITOR_VERSION, CKEDITOR } = window;
  if (!isCKCdnVersion(CKEDITOR_VERSION)) {
    return null;
  }
  return {
    source: CKEDITOR ? "cdn" : "npm",
    version: CKEDITOR_VERSION
  };
}
function getSupportedLicenseVersionInstallationInfo() {
  const installationInfo = getCKBaseBundleInstallationInfo();
  if (!installationInfo) {
    return null;
  }
  return getLicenseVersionFromEditorVersion(installationInfo.version);
}
function isCKEditorFreeLicense(licenseKey, licenseVersion) {
  licenseVersion || (licenseVersion = getSupportedLicenseVersionInstallationInfo() || void 0);
  switch (licenseVersion) {
    case 1:
    case 2:
      return licenseKey === void 0;
    case 3:
      return licenseKey === "GPL";
    default: {
      return false;
    }
  }
}
function createIntegrationUsageDataPlugin(integrationName, usageData) {
  return function IntegrationUsageDataPlugin(editor) {
    if (isCKEditorFreeLicense(editor.config.get("licenseKey"))) {
      return;
    }
    editor.on("collectUsageData", (source, { setUsageData }) => {
      setUsageData(`integration.${integrationName}`, usageData);
    });
  };
}
var CK_CDN_URL = "https://cdn.ckeditor.com";
function createCKCdnUrl(bundle, file, version2) {
  return `${CK_CDN_URL}/${bundle}/${version2}/${file}`;
}
var CKBOX_CDN_URL = "https://cdn.ckbox.io";
function createCKBoxCdnUrl(bundle, file, version2) {
  return `${CKBOX_CDN_URL}/${bundle}/${version2}/${file}`;
}
var CK_DOCS_URL = "https://ckeditor.com/docs/ckeditor5";
function createCKDocsUrl(path, version2 = "latest") {
  return `${CK_DOCS_URL}/${version2}/${path}`;
}
function createCKCdnBaseBundlePack({
  version: version2,
  translations,
  createCustomCdnUrl = createCKCdnUrl
}) {
  const urls = {
    scripts: [
      // Load the main script of the base features.
      createCustomCdnUrl("ckeditor5", "ckeditor5.umd.js", version2),
      // Load all JavaScript files from the base features.
      // EN bundle is prebuilt into the main script, so we don't need to load it separately.
      ...without(["en"], translations || []).map(
        (translation) => createCustomCdnUrl("ckeditor5", `translations/${translation}.umd.js`, version2)
      )
    ],
    stylesheets: [
      createCustomCdnUrl("ckeditor5", "ckeditor5.css", version2)
    ]
  };
  return {
    // Preload resources specified in the pack, before loading the main script.
    preload: [
      ...urls.stylesheets,
      ...urls.scripts
    ],
    scripts: [
      // It's safe to load translations and the main script in parallel.
      async (attributes) => injectScriptsInParallel(urls.scripts, attributes)
    ],
    // Load all stylesheets of the base features.
    stylesheets: urls.stylesheets,
    // Pick the exported global variables from the window object.
    checkPluginLoaded: async () => waitForWindowEntry(["CKEDITOR"]),
    // Check if the CKEditor base bundle is already loaded and throw an error if it is.
    beforeInject: () => {
      const installationInfo = getCKBaseBundleInstallationInfo();
      switch (installationInfo == null ? void 0 : installationInfo.source) {
        case "npm":
          throw new Error(
            "CKEditor 5 is already loaded from npm. Check the migration guide for more details: " + createCKDocsUrl("updating/migration-to-cdn/vanilla-js.html")
          );
        case "cdn":
          if (installationInfo.version !== version2) {
            throw new Error(
              `CKEditor 5 is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKEditor 5 to allow loading the ${version2} version.`
            );
          }
          break;
      }
    }
  };
}
function createCKCdnPremiumBundlePack({
  version: version2,
  translations,
  createCustomCdnUrl = createCKCdnUrl
}) {
  const urls = {
    scripts: [
      // Load the main script of the premium features.
      createCustomCdnUrl("ckeditor5-premium-features", "ckeditor5-premium-features.umd.js", version2),
      // Load all JavaScript files from the premium features.
      // EN bundle is prebuilt into the main script, so we don't need to load it separately.
      ...without(["en"], translations || []).map(
        (translation) => createCustomCdnUrl("ckeditor5-premium-features", `translations/${translation}.umd.js`, version2)
      )
    ],
    stylesheets: [
      createCustomCdnUrl("ckeditor5-premium-features", "ckeditor5-premium-features.css", version2)
    ]
  };
  return {
    // Preload resources specified in the pack, before loading the main script.
    preload: [
      ...urls.stylesheets,
      ...urls.scripts
    ],
    scripts: [
      // It's safe to load translations and the main script in parallel.
      async (attributes) => injectScriptsInParallel(urls.scripts, attributes)
    ],
    // Load all stylesheets of the premium features.
    stylesheets: urls.stylesheets,
    // Pick the exported global variables from the window object.
    checkPluginLoaded: async () => waitForWindowEntry(["CKEDITOR_PREMIUM_FEATURES"])
  };
}
async function loadCKCdnResourcesPack(pack) {
  let {
    htmlAttributes = {},
    scripts = [],
    stylesheets = [],
    preload,
    beforeInject,
    checkPluginLoaded
  } = normalizeCKCdnResourcesPack(pack);
  beforeInject == null ? void 0 : beforeInject();
  if (!preload) {
    preload = uniq([
      ...stylesheets.filter((item) => typeof item === "string"),
      ...scripts.filter((item) => typeof item === "string")
    ]);
  }
  for (const url of preload) {
    preloadResource(url, {
      attributes: htmlAttributes
    });
  }
  await Promise.all(
    uniq(stylesheets).map((href) => injectStylesheet({
      href,
      attributes: htmlAttributes,
      placementInHead: "start"
    }))
  );
  for (const script of uniq(scripts)) {
    const injectorProps = {
      attributes: htmlAttributes
    };
    if (typeof script === "string") {
      await injectScript(script, injectorProps);
    } else {
      await script(injectorProps);
    }
  }
  return checkPluginLoaded == null ? void 0 : checkPluginLoaded();
}
function normalizeCKCdnResourcesPack(pack) {
  if (Array.isArray(pack)) {
    return {
      scripts: pack.filter(
        (item) => typeof item === "function" || item.endsWith(".js")
      ),
      stylesheets: pack.filter(
        (item) => item.endsWith(".css")
      )
    };
  }
  if (typeof pack === "function") {
    return {
      checkPluginLoaded: pack
    };
  }
  return pack;
}
function combineCKCdnBundlesPacks(packs) {
  const normalizedPacks = mapObjectValues(
    filterBlankObjectValues(packs),
    normalizeCKCdnResourcesPack
  );
  const mergedPacks = Object.values(normalizedPacks).reduce(
    (acc, pack) => {
      acc.scripts.push(...pack.scripts ?? []);
      acc.stylesheets.push(...pack.stylesheets ?? []);
      acc.preload.push(...pack.preload ?? []);
      return acc;
    },
    {
      preload: [],
      scripts: [],
      stylesheets: []
    }
  );
  const checkPluginLoaded = async () => {
    var _a;
    const exportedGlobalVariables = /* @__PURE__ */ Object.create(null);
    for (const [name, pack] of Object.entries(normalizedPacks)) {
      exportedGlobalVariables[name] = await ((_a = pack == null ? void 0 : pack.checkPluginLoaded) == null ? void 0 : _a.call(pack));
    }
    return exportedGlobalVariables;
  };
  const beforeInject = () => {
    var _a;
    for (const pack of Object.values(normalizedPacks)) {
      (_a = pack.beforeInject) == null ? void 0 : _a.call(pack);
    }
  };
  return {
    ...mergedPacks,
    beforeInject,
    checkPluginLoaded
  };
}
function getCKBoxInstallationInfo() {
  var _a;
  const version2 = (_a = window.CKBox) == null ? void 0 : _a.version;
  if (!isSemanticVersion(version2)) {
    return null;
  }
  return {
    source: "cdn",
    version: version2
  };
}
function createCKBoxBundlePack({
  version: version2,
  theme = "lark",
  translations,
  createCustomCdnUrl = createCKBoxCdnUrl
}) {
  return {
    // Load the main script of the base features.
    scripts: [
      createCustomCdnUrl("ckbox", "ckbox.js", version2),
      // EN bundle is prebuilt into the main script, so we don't need to load it separately.
      ...without(["en"], translations || []).map(
        (translation) => createCustomCdnUrl("ckbox", `translations/${translation}.js`, version2)
      )
    ],
    // Load optional theme, if provided. It's not required but recommended because it improves the look and feel.
    ...theme && {
      stylesheets: [
        createCustomCdnUrl("ckbox", `styles/themes/${theme}.css`, version2)
      ]
    },
    // Pick the exported global variables from the window object.
    checkPluginLoaded: async () => waitForWindowEntry(["CKBox"]),
    // Check if the CKBox bundle is already loaded and throw an error if it is.
    beforeInject: () => {
      const installationInfo = getCKBoxInstallationInfo();
      if (installationInfo && installationInfo.version !== version2) {
        throw new Error(
          `CKBox is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKBox to allow loading the ${version2} version.`
        );
      }
    }
  };
}
function isCKCdnSupportedByEditorVersion(version2) {
  if (isCKCdnTestingVersion(version2)) {
    return true;
  }
  const { major } = destructureSemanticVersion(version2);
  const licenseVersion = getLicenseVersionFromEditorVersion(version2);
  switch (licenseVersion) {
    case 3:
      return true;
    default:
      return major === 43;
  }
}
function combineCdnPluginsPacks(pluginsPacks) {
  const normalizedPluginsPacks = mapObjectValues(pluginsPacks, (pluginPack, pluginName) => {
    if (!pluginPack) {
      return void 0;
    }
    const normalizedPluginPack = normalizeCKCdnResourcesPack(pluginPack);
    return {
      // Provide default window accessor object if the plugin pack does not define it.
      checkPluginLoaded: async () => waitForWindowEntry([pluginName]),
      // Transform the plugin pack to a normalized advanced pack.
      ...normalizedPluginPack
    };
  });
  return combineCKCdnBundlesPacks(
    normalizedPluginsPacks
  );
}
function loadCKEditorCloud(config) {
  const {
    version: version2,
    translations,
    plugins,
    premium,
    ckbox,
    createCustomCdnUrl,
    injectedHtmlElementsAttributes = {
      crossorigin: "anonymous"
    }
  } = config;
  validateCKEditorVersion(version2);
  const pack = combineCKCdnBundlesPacks({
    CKEditor: createCKCdnBaseBundlePack({
      version: version2,
      translations,
      createCustomCdnUrl
    }),
    ...premium && {
      CKEditorPremiumFeatures: createCKCdnPremiumBundlePack({
        version: version2,
        translations,
        createCustomCdnUrl
      })
    },
    ...ckbox && {
      CKBox: createCKBoxBundlePack(ckbox)
    },
    loadedPlugins: combineCdnPluginsPacks(plugins ?? {})
  });
  return loadCKCdnResourcesPack(
    {
      ...pack,
      htmlAttributes: injectedHtmlElementsAttributes
    }
  );
}
function validateCKEditorVersion(version2) {
  if (isCKCdnTestingVersion(version2)) {
    console.warn(
      "You are using a testing version of CKEditor 5. Please remember that it is not suitable for production environments."
    );
  }
  if (!isCKCdnSupportedByEditorVersion(version2)) {
    throw new Error(
      `The CKEditor 5 CDN can't be used with the given editor version: ${version2}. Please make sure you are using at least the CKEditor 5 version 44.`
    );
  }
}

// node_modules/@ckeditor/ckeditor5-vue/dist/ckeditor.js
var VueIntegrationUsageDataPlugin = createIntegrationUsageDataPlugin(
  "vue",
  {
    version: "7.3.0",
    frameworkVersion: version
  }
);
function appendAllIntegrationPluginsToConfig(editorConfig) {
  if (isCKEditorFreeLicense(editorConfig.licenseKey)) {
    return editorConfig;
  }
  return appendExtraPluginsToEditorConfig(editorConfig, [
    /**
     * This part of the code is not executed in open-source implementations using a GPL key.
     * It only runs when a specific license key is provided. If you are uncertain whether
     * this applies to your installation, please contact our support team.
     */
    VueIntegrationUsageDataPlugin
  ]);
}
var VUE_INTEGRATION_READ_ONLY_LOCK_ID = "Lock from Vue integration (@ckeditor/ckeditor5-vue)";
var INPUT_EVENT_DEBOUNCE_WAIT = 300;
var _sfc_main = defineComponent({
  ...{
    name: "CKEditor"
  },
  __name: "ckeditor",
  props: mergeModels({
    editor: {},
    config: { default: () => ({}) },
    tagName: { default: "div" },
    disabled: { type: Boolean, default: false },
    disableTwoWayDataBinding: { type: Boolean, default: false }
  }, {
    "modelValue": { type: String, default: "" },
    "modelModifiers": {}
  }),
  emits: mergeModels(["ready", "destroy", "blur", "focus", "input", "update:modelValue"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const model = useModel(__props, "modelValue");
    const props = __props;
    const emit = __emit;
    const element = ref();
    const instance = ref();
    const lastEditorData = ref();
    __expose({
      instance,
      lastEditorData
    });
    watch(model, (newModel) => {
      if (instance.value && newModel !== lastEditorData.value) {
        instance.value.data.set(newModel);
      }
    });
    watch(() => props.disabled, (readOnlyMode) => {
      if (readOnlyMode) {
        instance.value.enableReadOnlyMode(VUE_INTEGRATION_READ_ONLY_LOCK_ID);
      } else {
        instance.value.disableReadOnlyMode(VUE_INTEGRATION_READ_ONLY_LOCK_ID);
      }
    });
    function checkVersion() {
      const version2 = window.CKEDITOR_VERSION;
      if (!version2) {
        return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
      }
      const [major] = version2.split(".").map(Number);
      if (major >= 42 || version2.startsWith("0.0.0")) {
        return;
      }
      console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
    }
    function setUpEditorEvents(editor) {
      const emitDebouncedInputEvent = debounce_default((evt) => {
        if (props.disableTwoWayDataBinding) {
          return;
        }
        const data = lastEditorData.value = editor.data.get();
        emit("update:modelValue", data, evt, editor);
        emit("input", data, evt, editor);
      }, INPUT_EVENT_DEBOUNCE_WAIT, { leading: true });
      editor.model.document.on("change:data", emitDebouncedInputEvent);
      editor.editing.view.document.on("focus", (evt) => {
        emit("focus", evt, editor);
      });
      editor.editing.view.document.on("blur", (evt) => {
        emit("blur", evt, editor);
      });
    }
    checkVersion();
    onMounted(() => {
      const editorConfig = appendAllIntegrationPluginsToConfig(
        Object.assign({}, props.config)
      );
      if (model.value) {
        editorConfig.initialData = model.value;
      }
      props.editor.create(element.value, editorConfig).then((editor) => {
        instance.value = markRaw(editor);
        setUpEditorEvents(editor);
        if (model.value !== editorConfig.initialData) {
          editor.data.set(model.value);
        }
        if (props.disabled) {
          editor.enableReadOnlyMode(VUE_INTEGRATION_READ_ONLY_LOCK_ID);
        }
        emit("ready", editor);
      }).catch((error) => {
        console.error(error);
      });
    });
    onBeforeUnmount(() => {
      if (instance.value) {
        instance.value.destroy();
        instance.value = void 0;
      }
      emit("destroy");
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagName), {
        ref_key: "element",
        ref: element
      }, null, 512);
    };
  }
});
var useAsync = (asyncFunc) => {
  const lastQueryUUID = ref(null);
  const error = ref(null);
  const data = ref(null);
  const loading = computed(() => lastQueryUUID.value !== null);
  watchEffect(async () => {
    const currentQueryUID = uid();
    lastQueryUUID.value = currentQueryUID;
    data.value = null;
    error.value = null;
    const shouldDiscardQuery = () => lastQueryUUID.value !== currentQueryUID;
    try {
      const result = await asyncFunc();
      if (!shouldDiscardQuery()) {
        data.value = result;
      }
    } catch (err) {
      if (!shouldDiscardQuery()) {
        error.value = err;
      }
    } finally {
      if (!shouldDiscardQuery()) {
        lastQueryUUID.value = null;
      }
    }
  });
  return {
    loading: shallowReadonly(loading),
    data: shallowReadonly(data),
    error: shallowReadonly(error)
  };
};
function useCKEditorCloud(config) {
  return useAsync(
    () => loadCKEditorCloud(
      toValue(config)
    )
  );
}
if (!version || !version.startsWith("3.")) {
  throw new Error(
    "The CKEditor plugin works only with Vue 3+. For more information, please refer to https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs-v3.html"
  );
}
var CkeditorPlugin = {
  /**
   * Installs the plugin, registering the `<ckeditor>` component.
   *
   * @param app The application instance.
   */
  install(app) {
    app.component("Ckeditor", _sfc_main);
  }
};
export {
  _sfc_main as Ckeditor,
  CkeditorPlugin,
  loadCKEditorCloud,
  useCKEditorCloud
};
/*! Bundled license information:

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-integrations-common/dist/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-vue/dist/ckeditor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   *)
  (* istanbul ignore if -- @preserve *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-vue.js.map
